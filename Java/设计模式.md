[TOC]

# 1 创建型

##  1.1 *工厂方法模式（Factory Method Pattern）

```java
public interface Person{
    void drink();
}

public class Man implements Person(
	@Override
    public void drink(){
        System.out.print("The man is Drink");
    }
)
    
   public class PersonFactory {
    
   //使用 getPerson 方法获取人物种类
   public Person getPerson(String personType){
      if(personType == null){
         return null;
      }        
      if(personType.equalsIgnoreCase("Man")){
         return new Man();
      } else if(personType.equalsIgnoreCase("Woman")){
         return new Rectangle();
      }
      return null;
   }
}
```

##  1.2 抽象工厂模式（Abstract Factory Pattern）

## 1.3 *建造者模式（Builder Pattern）

> 例子:肯德基的套餐;薯条,可乐等不变,变化的只是套餐的组合.
>
> 使用场景:1.需要生成的对象具有复杂的内部结构,2.需要生成的对象内部属性本身相互依赖
>
> 描述:使用多个简单对象一步步构建成一个复杂的对象.这种类型的设计模式属于创建型模式,它提供了一种创建对象的最佳方式.

```java
//食品条目
public interface Item{
    //食品名称
    public String name;
    //打包方式
    public Packing packing();
    //食品价格
    public float price();
}
```

```java
public interface Packing{
    public String pack();
}

//纸张打包
public class PaperWrapper implements Packing{
   @Override
   public String pack() {
      return "PaperWrapper";
   }
}

//杯子包装
public class Bottle implements Packing{
   @Override
   public String pack() {
      return "Bottle";
   }
}
```

```java
//种类实现
//汉堡
public abstract class Burger implements Item {
 
   @Override
   public Packing packing() {
      return new PaperWrapper();
   }
   @Override
   public abstract float price();
}

//酒水饮料
public abstract class ColdDrink implements Item {
 
    @Override
    public Packing packing() {
       return new Bottle();
    }
    @Override
    public abstract float price();
}
```

```java
//具体种类实现  --鸡肉汉堡
//到现在  名称,价格,打包方式  三种都存在了
public class ChickenBurger extends Burger {
 
   @Override
   public float price() {
      return 50.5f;
   }
 
   @Override
   public String name() {
      return "Chicken Burger";
   }
}
```

```java
public class Meal {
   private List<Item> items = new ArrayList<Item>();    
 
   public void addItem(Item item){
      items.add(item);
   }
 
   public float getCost(){
      float cost = 0.0f;
      for (Item item : items) {
         cost += item.price();
      }        
      return cost;
   }
 
   public void showItems(){
      for (Item item : items) {
         System.out.print("Item : "+item.name());
         System.out.print(", Packing : "+item.packing().pack());
         System.out.println(", Price : "+item.price());
      }        
   }    
}

//建造者模式  可以实现组装
public class MealBuilder {
 
   public Meal prepareVegMeal (){
      Meal meal = new Meal();
      meal.addItem(new VegBurger());
      meal.addItem(new Coke());
      return meal;
   }   
 
   public Meal prepareNonVegMeal (){
      Meal meal = new Meal();
      meal.addItem(new ChickenBurger());
      meal.addItem(new Pepsi());
      return meal;
   }
}
```





## 1.4 *原型模式（Prototype Pattern）

> 与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。
>
> 浅拷贝实现 Cloneable，重写;
>
> 深拷贝是通过实现 Serializable 读取二进制流。

```java
具体内容,有点迷惑
```



## 1.5 *单例模式（Singleton Pattern）

- 简单实现

  ```java
  public class SingleObject{
      private static SingleObject instance = new SingleObject();
      
      //构造函数私有,就不能实例化了
      private SingleObject(){
          
      }
      //调用方法
       public static SingleObject getInstance(){
        return instance;
     }
  }
  ```

  > 下面是几种实现方式

  - 饿汉模式:常用,但是容易产生垃圾,类加载时候进行初始化.

    ```java
    public class Singleton {  
        private static Singleton instance = new Singleton();  
        private Singleton (){}  
        public static Singleton getInstance() {  
        return instance;  
        }  
    }
    ```

    

  - ### 双检锁/双重校验锁（DCL，即 double-checked locking）

    ```java
    public class Singleton {  
        private volatile static Singleton singleton;  
        private Singleton (){};
        public static Singleton getSingleton() {  
        if (singleton == null) {  
            synchronized (Singleton.class) {  
            if (singleton == null) {  
                singleton = new Singleton();  
            }  
            }  
        }  
        return singleton;  
        }  
    }
    ```

    

# 2 结构型

##  2.1 *适配器模式（Adapter Pattern）

```java
//创建一个SDCard接口
public interface SDCard {
    //读取SD卡方法
    String readSD();
    //写入SD卡功能
    int writeSD(String msg);
}
//创建SDCard接口的实现类
public class SDCardImpl implements SDCard {
    String msg = null;
   @Override    
    public String readSD() {
         msg = "sdcard read a msg :hello word SD";
        return msg;  
    }
    @Override  
    public int writeSD(String msg) {      
        System.out.println("sd card write msg : " + msg);    
        return 1;   
    }
}
```

```java
//创建计算机的接口
public interface Computer {    
    String readSD(SDCard sdCard);
}

//计算机对接口的实现
public class ThinkpadComputer implements Computer {
    @Override    
    public String readSD(SDCard sdCard) {        
        if(sdCard == null)
            throw new NullPointerException("sd card null");        
        return sdCard.readSD();    
    }
}
```

```java
//适配器执行
public class ComputerReadDemo {    
    public static void main(String[] args) {
        //电脑
        Computer computer = new ThinkpadComputer();
        //SD卡
        SDCard sdCard = new SDCardImpl(); 
        //计算机读取
        computer.readSD(sdCard);    
    }
}
```

```java
//适配器使用
public class SDAdapterTF implements SDCard {    
    private TFCard tfCard;    
    public SDAdapterTF(TFCard tfCard) {        
        this.tfCard = tfCard;    
    }    
    @Override    
    public String readSD() {        
        System.out.println("adapter read tf card ");        
        return tfCard.readTF();    
    }    
    @Override    
    public int writeSD(String msg) {        
        System.out.println("adapter write tf card");        
        return tfCard.writeTF(msg);    
    }
}

//执行
public class ComputerReadDemo {    
    public static void main(String[] args) {        
        Computer computer = new ThinkpadComputer();        
        SDCard sdCard = new SDCardImpl();        
        System.out.println(computer.readSD(sdCard));        
        System.out.println("====================================");        
        TFCard tfCard = new TFCardImpl();        
        SDCard tfCardAdapterSD = new SDAdapterTF(tfCard);        
        System.out.println(computer.readSD(tfCardAdapterSD));    
    }
}
```

> <font color=red>**理解:适配器中通过不同的实现方法来进行匹配**</font>

##  2.2 *桥接模式（Bridge Pattern）

- 将类的功能层次结构和实现层次结构相分离,使二者能够独立变化,并在两者之间搭建桥梁,实现桥接

```java
//画东西接口
public interface Draw{
    public void drawCricel(int radius,int x, int y);
}

//画红色的圆
public RedCircleDraw implements Draw{
    public void drawCricel(int radius,int x, int y){
        System.out.println("画红色的圆");
    };
}

//画红色的圆
public GreenCircleDraw implements Draw{
    public void drawCricel(int radius,int x, int y){
        System.out.println("画绿色的圆");
    };
}
```

```java
public abstract class Shape {
    //引入
   protected Draw draw;
   protected Shape(Draw draw){
      this.draw = draw;
   }
   public abstract void draw();  
}

//shape的实现:画圆
public class Circle extends Shape {
   public Circle(DrawA draw) {
      super(draw);
      this.radius = radius;
   }
   public void draw() {
      draw.drawCircle(radius,x,y);
   }
```

```java
//实现
public class Main{
    public static void main(String[] args){
        Circle circle = new Circle(new RedCircleDraw());
        System.out.println(circle.draw());
        
        Circle circle = new Circle(new GreenCircleDraw());
        System.out.println(circle.draw());
    }
}
> 输出内容: 画红色的圆
		   画绿色的圆
```



##   2.3 *组合模式（Composite Pattern）

> 介绍:Java的AWT和SWING中,对Button和Checkbox是树叶,Container是树枝
>
> 优点:1.高层模块调用简单 2.节点增加自由
>
> 缺点:使用组合时候,叶子和树枝都是实现类,不是接口,违反了依赖倒置原则
>
> 使用场景:部分,整体场景;如:树形菜单,文件夹

```xml
//组合模式，就是在一个对象中包含其他对象，这些被包含的对象可能是终点对象（不再包含别的对象），
//也有可能是非终点对象（其内部还包含其他对象，或叫组对象），
//我们将对象称为节点，即一个根节点包含许多子节点，
//这些子节点有的不再包含子节点，而有的仍然包含子节点，以此类推。
```

```java
实际逻辑:
	一个实体类:员工
	员工:老板--->CTO
				--->经理
			--->CMO
				--->C经理
			--->财务总监
				--->财务经理
按照等级分
			
```



##   2.4 *装饰者模式（Decorator Pattern）

- 允许向一个现有的对象添加新功能,同时不改变其结构.
- 创建一个装饰类来包装原有的类,保持原类方法签名完整的前提下,提供额外的功能

```java
//图形:画
public interface Shape{
    void draw();
}

//画圆
public class Circle implements Shape{
    @Override
    public void draw(){
        System.out.println("画圆");
    }
}

//画方形
public class Rectangle implements Shape{
    @Override
    public void draw(){
        System.out.println("方形");
    }
}
```

```java
//形状装饰 抽象
public abstract class ShapeDecorator implements Shape {
   protected Shape decoratedShape;
 
   public ShapeDecorator(Shape decoratedShape){
      this.decoratedShape = decoratedShape;
   }

   public void draw(){
      decoratedShape.draw();
   }  
}
//红色装饰 实现
public class RedShapeDecorator extends ShapeDecorator {
 
   public RedShapeDecorator(Shape decoratedShape) {
      super(decoratedShape);     
   }
 
   @Override
   public void draw() {
      decoratedShape.draw();         
      setRedBorder(decoratedShape);
   }
   private void setRedBorder(Shape decoratedShape){
      System.out.println("Border Color: Red");
   }
}
//以上在打印了 形状以后   会后续打印出来  颜色   :相当于给物品上色
```



##   2.5 *外观模式（Facade Pattern）

- 隐藏系统的复杂性,向客户端提供了一个访问系统的接口.

- 意图:为子系统的一组接口提供了一个一致性的界面,外观模式定义一个高级接口,这个接口使得子系统更加容易使用

- 应用实例:1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。      2、JAVA 的三层开发模式。

  ```java
  圆形
  	:draw 画圆
  长方形
  	:draw 画长方形
  正方形
  	:draw 画正方形
  ```

  ```java
  外观类
  	public void drawCircle(){
        circle.draw();
     }
     public void drawRectangle(){
        rectangle.draw();
     }
     public void drawSquare(){
        square.draw();
     }
    
  具体实现:
  //第一步:画圆
  	外观类.drawCircle();
  //第二步:画长方形
  	外观类.drawRectangle();
  //第三步:画正方形
  	外观类.drawSquare();
  ```

  

##   2.6 享元模式（Flyweight Pattern）
##   2.7 代理模式（Proxy Pattern）

# 3 行为型

## 3.1 责任链模式（Chain of Responsibility Pattern）
## 3.2 命令模式（Command Pattern）
##  3.3 解释器模式（Interpreter Pattern）
##  3.4 迭代器模式（Iterator Pattern）
##  3.5 中介者模式（Mediator Pattern）
##  3.6 备忘录模式（Memento Pattern）
##  3.7 观察者模式（Observer Pattern）
##  3.8 状态模式（State Pattern）
##  3.9 策略模式（Strategy Pattern）
##  3.10 模板方法模式（Template Method Pattern）
##  3.11 访问者模式（Visitor Pattern）


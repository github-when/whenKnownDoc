[TOC]

# 1 创建型

##  1.1 *工厂方法模式（Factory Method Pattern）

```java
public interface Person{
    void drink();
}

public class Man implements Person(
	@Override
    public void drink(){
        System.out.print("The man is Drink");
    }
)
    
   public class PersonFactory {
    
   //使用 getPerson 方法获取人物种类
   public Person getPerson(String personType){
      if(personType == null){
         return null;
      }        
      if(personType.equalsIgnoreCase("Man")){
         return new Man();
      } else if(personType.equalsIgnoreCase("Woman")){
         return new Rectangle();
      }
      return null;
   }
}
```

##  1.2 抽象工厂模式（Abstract Factory Pattern）

## 1.3 *建造者模式（Builder Pattern）

> 例子:肯德基的套餐;薯条,可乐等不变,变化的只是套餐的组合.
>
> 使用场景:1.需要生成的对象具有复杂的内部结构,2.需要生成的对象内部属性本身相互依赖
>
> 描述:使用多个简单对象一步步构建成一个复杂的对象.这种类型的设计模式属于创建型模式,它提供了一种创建对象的最佳方式.

```java
//食品条目
public interface Item{
    //食品名称
    public String name;
    //打包方式
    public Packing packing();
    //食品价格
    public float price();
}
```

```java
public interface Packing{
    public String pack();
}

//纸张打包
public class PaperWrapper implements Packing{
   @Override
   public String pack() {
      return "PaperWrapper";
   }
}

//杯子包装
public class Bottle implements Packing{
   @Override
   public String pack() {
      return "Bottle";
   }
}
```

```java
//种类实现
//汉堡
public abstract class Burger implements Item {
 
   @Override
   public Packing packing() {
      return new PaperWrapper();
   }
   @Override
   public abstract float price();
}

//酒水饮料
public abstract class ColdDrink implements Item {
 
    @Override
    public Packing packing() {
       return new Bottle();
    }
    @Override
    public abstract float price();
}
```

```java
//具体种类实现  --鸡肉汉堡
//到现在  名称,价格,打包方式  三种都存在了
public class ChickenBurger extends Burger {
 
   @Override
   public float price() {
      return 50.5f;
   }
 
   @Override
   public String name() {
      return "Chicken Burger";
   }
}
```

```java
public class Meal {
   private List<Item> items = new ArrayList<Item>();    
 
   public void addItem(Item item){
      items.add(item);
   }
 
   public float getCost(){
      float cost = 0.0f;
      for (Item item : items) {
         cost += item.price();
      }        
      return cost;
   }
 
   public void showItems(){
      for (Item item : items) {
         System.out.print("Item : "+item.name());
         System.out.print(", Packing : "+item.packing().pack());
         System.out.println(", Price : "+item.price());
      }        
   }    
}

//建造者模式  可以实现组装
public class MealBuilder {
 
   public Meal prepareVegMeal (){
      Meal meal = new Meal();
      meal.addItem(new VegBurger());
      meal.addItem(new Coke());
      return meal;
   }   
 
   public Meal prepareNonVegMeal (){
      Meal meal = new Meal();
      meal.addItem(new ChickenBurger());
      meal.addItem(new Pepsi());
      return meal;
   }
}
```





## 1.4 *原型模式（Prototype Pattern）

> 与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。
>
> 浅拷贝实现 Cloneable，重写;
>
> 深拷贝是通过实现 Serializable 读取二进制流。

```java
具体内容,有点迷惑
```



## 1.5 *单例模式（Singleton Pattern）

- 简单实现

  ```java
  public class SingleObject{
      private static SingleObject instance = new SingleObject();
      
      //构造函数私有,就不能实例化了
      private SingleObject(){
          
      }
      //调用方法
       public static SingleObject getInstance(){
        return instance;
     }
  }
  ```

  > 下面是几种实现方式

  - 饿汉模式:常用,但是容易产生垃圾,类加载时候进行初始化.

    ```java
    public class Singleton {  
        private static Singleton instance = new Singleton();  
        private Singleton (){}  
        public static Singleton getInstance() {  
        return instance;  
        }  
    }
    ```

    

  - ### 双检锁/双重校验锁（DCL，即 double-checked locking）

    ```java
    public class Singleton {  
        private volatile static Singleton singleton;  
        private Singleton (){};
        public static Singleton getSingleton() {  
        if (singleton == null) {  
            synchronized (Singleton.class) {  
            if (singleton == null) {  
                singleton = new Singleton();  
            }  
            }  
        }  
        return singleton;  
        }  
    }
    ```

    

# 2 结构型

##  2.1 *适配器模式（Adapter Pattern）

```java
//创建一个SDCard接口
public interface SDCard {
    //读取SD卡方法
    String readSD();
    //写入SD卡功能
    int writeSD(String msg);
}
//创建SDCard接口的实现类
public class SDCardImpl implements SDCard {
    String msg = null;
   @Override    
    public String readSD() {
         msg = "sdcard read a msg :hello word SD";
        return msg;  
    }
    @Override  
    public int writeSD(String msg) {      
        System.out.println("sd card write msg : " + msg);    
        return 1;   
    }
}
```

```java
//创建计算机的接口
public interface Computer {    
    String readSD(SDCard sdCard);
}

//计算机对接口的实现
public class ThinkpadComputer implements Computer {
    @Override    
    public String readSD(SDCard sdCard) {        
        if(sdCard == null)
            throw new NullPointerException("sd card null");        
        return sdCard.readSD();    
    }
}
```

```java
//适配器执行
public class ComputerReadDemo {    
    public static void main(String[] args) {
        //电脑
        Computer computer = new ThinkpadComputer();
        //SD卡
        SDCard sdCard = new SDCardImpl(); 
        //计算机读取
        computer.readSD(sdCard);    
    }
}
```

```java
//适配器使用
public class SDAdapterTF implements SDCard {    
    private TFCard tfCard;    
    public SDAdapterTF(TFCard tfCard) {        
        this.tfCard = tfCard;    
    }    
    @Override    
    public String readSD() {        
        System.out.println("adapter read tf card ");        
        return tfCard.readTF();    
    }    
    @Override    
    public int writeSD(String msg) {        
        System.out.println("adapter write tf card");        
        return tfCard.writeTF(msg);    
    }
}

//执行
public class ComputerReadDemo {    
    public static void main(String[] args) {        
        Computer computer = new ThinkpadComputer();        
        SDCard sdCard = new SDCardImpl();        
        System.out.println(computer.readSD(sdCard));        
        System.out.println("====================================");        
        TFCard tfCard = new TFCardImpl();        
        SDCard tfCardAdapterSD = new SDAdapterTF(tfCard);        
        System.out.println(computer.readSD(tfCardAdapterSD));    
    }
}
```

> <font color=red>**理解:适配器中通过不同的实现方法来进行匹配**</font>

##  2.2 *桥接模式（Bridge Pattern）

- 将类的功能层次结构和实现层次结构相分离,使二者能够独立变化,并在两者之间搭建桥梁,实现桥接

```java
//画东西接口
public interface Draw{
    public void drawCricel(int radius,int x, int y);
}

//画红色的圆
public RedCircleDraw implements Draw{
    public void drawCricel(int radius,int x, int y){
        System.out.println("画红色的圆");
    };
}

//画红色的圆
public GreenCircleDraw implements Draw{
    public void drawCricel(int radius,int x, int y){
        System.out.println("画绿色的圆");
    };
}
```

```java
public abstract class Shape {
    //引入
   protected Draw draw;
   protected Shape(Draw draw){
      this.draw = draw;
   }
   public abstract void draw();  
}

//shape的实现:画圆
public class Circle extends Shape {
   public Circle(DrawA draw) {
      super(draw);
      this.radius = radius;
   }
   public void draw() {
      draw.drawCircle(radius,x,y);
   }
```

```java
//实现
public class Main{
    public static void main(String[] args){
        Circle circle = new Circle(new RedCircleDraw());
        System.out.println(circle.draw());
        
        Circle circle = new Circle(new GreenCircleDraw());
        System.out.println(circle.draw());
    }
}
> 输出内容: 画红色的圆
		   画绿色的圆
```



##   2.3 组合模式（Composite Pattern）
##   2.4 装饰者模式（Decorator Pattern）
##   2.5 外观模式（Facade Pattern）
##   2.6 享元模式（Flyweight Pattern）
##   2.7 代理模式（Proxy Pattern）

# 3 行为型

## 3.1 责任链模式（Chain of Responsibility Pattern）
## 3.2 命令模式（Command Pattern）
##  3.3 解释器模式（Interpreter Pattern）
##  3.4 迭代器模式（Iterator Pattern）
##  3.5 中介者模式（Mediator Pattern）
##  3.6 备忘录模式（Memento Pattern）
##  3.7 观察者模式（Observer Pattern）
##  3.8 状态模式（State Pattern）
##  3.9 策略模式（Strategy Pattern）
##  3.10 模板方法模式（Template Method Pattern）
##  3.11 访问者模式（Visitor Pattern）

